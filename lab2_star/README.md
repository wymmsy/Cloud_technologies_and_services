## Лабораторная работа 2*

К имеющимся во 2 лабораторной работе файлам я добавила следующие:

В docker‑compose части у меня в итоге получилось 4 bad practice, и каждая из них исправлена в «хорошем» файле.

### 1. Использование latest вместо фиксированных версий образов
В плохом файле (docker-compose.bad.yml):

Для всех сервисов указаны образы без конкретных версий:
image: nginx:latest, image: postgres:latest, image: redis:latest.
​
Такая запись делает сборки непредсказуемыми, при любом обновлении образа конфигурация может ломаться без изменения compose файла, и воспроизвести старое состояние будет сложно.

В хорошем файле (docker-compose.good.yml):

Для каждого сервиса указаны конкретные теги:
docker.io/nginx:1.25-alpine, docker.io/postgres:15-alpine, docker.io/redis:7-alpine.
​

Так мы фиксируем версию и делаем деплой воспроизводимым: одно и то же состояние можно восстановить на разных машинах, и обновления образов будут осознанными, только через явное изменение тега в YAML.

### 2. Хранение паролей и строк подключения в YAML
В плохом файле:

Пароли и параметры доступа к БД прописаны прямо в environment:

text
environment:
  POSTGRES_PASSWORD: qwerty123
  POSTGRES_USER: admin
  POSTGRES_DB: mydb
а в web вся строка подключения с паролем зашита в DB_URL.
​

В Redis пароль передаётся в command:
command: redis-server --requirepass "simplepass".
​

Такой подход небезопасный, так как вся конфиденциальная информация попадает в git‑репозиторий, в историю и так далее, их сложнее менять, становится высоким риск утечки.

В хорошем файле:

Вместо конкретных значений используются ссылки на переменные окружения:

text
environment:
  POSTGRES_PASSWORD: ${DB_PASSWORD}
  POSTGRES_USER: ${DB_USER}
  POSTGRES_DB: ${DB_NAME}
а Redis получает пароль из ${REDIS_PASSWORD}.
​

Значения заданы в отдельном .env‑файле (или через переменные окружения при запуске), который можно не коммитить в репозиторий.

Так мы повысили безопасность и упростили себе настройку разных окружений (локально, на сервере, у коллеги) без изменения compose‑файла.

### 3. Некорректная политика рестарта и отсутствие healthcheck
В плохом файле:

Для web‑сервиса указано restart: always, у остальных сервисов вообще нет healthcheck.
​

restart: always 
Чтобы контейнер бесконечно перезапускалсяся даже при ошибке конфигурации или падении приложения, а тем временм внешне будет казаться, что всё номарльно работает.

Отсутствие healthcheck означает, что orchestrator никак не отличает «живой, но не готовый» сервис от полностью рабочей БД или Redis.

В хорошем файле:

Для сервисов используется более аккуратная политика restart: unless-stopped, которая перезапускает контейнеры при сбоях, но не мешает их явно останавливать при обслуживании.
​

Для Postgres и Redis добавлены healthcheck‑и:

text
healthcheck:
  test: ["CMD-SHELL", "pg_isready -U ${DB_USER} -d${DB_NAME}"]
  interval: 10s
  timeout: 5s
  retries: 3
и

text
healthcheck:
  test: ["CMD", "redis-cli", "ping"]
  interval: 10s
  timeout: 3s
  retries: 3
Это позволяет compose (или аналогичному оркестратору) понимать, когда сервис действительно готов к работе, и при необходимости перезапускать его или не запускать зависящие сервисы, пока БД/Redis не поднялись.

### 4. Жёсткое пробрасывание портов без ограничения интерфейса
В плохом файле (дополнительная плохая практика):

Web‑контейнер публикует порт как:

text
ports:
  - "80:80"
Это открывает порт nginx на всех интерфейсах хоста, что для учебной/локальной конфигурации терпимо, но для прод‑подобной среды — рискованно.

В хорошем файле:

Порт ограничен loopback‑интерфейсом:

text
ports:
  - "127.0.0.1:8080:80"
В результате веб‑интерфейс доступен только с локальной машины (или из виртуалки), что снижает поверхность атаки и лучше соответствует принципу минимально необходимого доступа.


## Ход работы:
Сначала снова собрала и запустила плохой и хороший контейнеры.

Запустила команду для сборки образа хорошего докерфайла
docker build -f bad.Dockerfile -t lab2_bad_image .  
Потом у меня кончилась память на диске…. (он уже не выдерживает конец семестра)


Освободила место и, победа, образ собрался.

Теперь все контейнеры запущены.
Для выполнения части со звездочкой:


После sudo apt-get update:

ЗДесь я столкнулась с проблемой.
В используемой виртуальной машине (Linux Mint 22, Python 3.12) предустановленная утилита docker-compose не работает из‑за ошибки ModuleNotFoundError: No module named 'distutils'. Все мои попытки установить python3-distutils и docker-compose-plugin заканчивались поражением, так как эти пакеты отсутствуют в репозитории. Поэтому запуск сервисов я выполнила через отдельные команды docker run, а файлы docker-compose.bad.yml и docker-compose.good.yml использовала дальше как примеры неправильной и исправленной конфигурации.

Запуск «ручного аналога» docker-compose.good.yml:


Успешно сработал.

Для хорошего варианта был использован образ python:3.11-slim-bullseye, зависимости вынесены в requirements.txt, а секреты убраны из Dockerfile и передаются только через переменные окружения при запуске. Сборка выполнялась командой docker build -f good.Dockerfile -t lab2_good_image ., при запуске контейнера видно другое текстовое сообщение и отсутствие захардкоженного ключа, что позволяет на защите чётко показать отличие безопасной конфигурации от уязвимой.

При попытке использовать docker‑compose для запуска нескольких сервисов в виртуальной машине Linux Mint 22 возникла ошибка ModuleNotFoundError: No module named 'distutils' внутри предустановленной утилиты docker-compose. Попытки доустановить пакеты python3-distutils и docker-compose-plugin оказались безуспешными из‑за отсутствия подходящих пакетов в репозитории, поэтому для практической части было принято решение запускать сервисы эквивалентными командами docker run, а сами файлы docker-compose.bad.yml и docker-compose.good.yml использовать в отчёте как иллюстрацию неправильной и исправленной конфигурации.

«Хороший» вариант docker‑compose был воспроизведён вручную через три команды docker run, каждая из которых повторяет настройки соответствующего сервиса из docker-compose.good.yml (фиксированные версии образов, том для данных Postgres, пароли через переменные окружения и отдельные сети). На скринах видно, что nginx успешно стартует и отдаёт страницу по http://localhost:8080, Postgres завершает инициализацию с сообщением database system is ready to accept connections, а Redis принимает соединения с заданным паролем, что подтверждает корректность конфигурации и позволяет считать цели лабораторной работы выполненными, несмотря на проблемы с утилитой docker‑compose в используемом дистрибутиве.
​




