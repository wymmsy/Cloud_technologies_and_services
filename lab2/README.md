# Лабораторная работа 2: Плохие и хорошие практики в Docker

## Часть 1: Dockerfile

### Плохие практики в `bad.Dockerfile` и их исправление в `good.Dockerfile`

1.  **Использование тега `latest`**
    *   **Почему это плохо:** Тег `latest` плавающий, и поэтому сборка, которая работала сегодня, может сломаться завтра из-за обновления базового образа. Это нарушает принцип воспроизводимости.
    *   **Исправление:** В `good.Dockerfile` изпользуется конкретный тег `python:3.11-slim-bullseye`, чтобы все сборки гарантировано использовали одну и ту же среду.
    *   **Результат:** Сборки стали стабильными и воспроизводимыми.

2.  **Неоптимальное использование инструкций `RUN` и `COPY`**
    *   **Почему это плохо:** Каждая инструкция в Dockerfile создает новый слой, и несколько команд `RUN` подряд увеличивают итоговый размер образа. Копирование всего проекта (`COPY . /app`) в начале не позволяет эффективно использовать кэш. Любое изменение в любом файле проекта приведет к инвалидации кэша для всех последующих слоев, включая слой с установкой зависимостей.
    *   **Исправление:** В `good.Dockerfile` сначала копируется только `requirements.txt`, и зависимости устанавливаются одной командой `RUN`, а остальной код копируется отдельно. Кэш pip очищается в той же команде.
    *   **Результат:** Размер образа уменьшен, сборки стали быстрее, так как слой с зависимостями пересобирается только при изменении `requirements.txt`, а не при любом изменении кода.

3.  **Хранение секретов в Dockerfile**
    *   **Почему это плохо:** Переменные, заданные через `ENV`, остаются в истории образа и видны при его инспектировании, что делает сектерные данные уязвимыми.
    *   **Исправление:** Секретные коды полностью удалены из `good.Dockerfile`. Они должны передаваться в контейнер во время выполнения, например, с помощью `docker run --env-file .env` или через оркестраторы (Kubernetes Secrets, Docker Swarm secrets).
    *   **Результат:** Повышение безопасности, секретные данные не попадают в финальный образ.

### Две плохие практики по работе с контейнерами (не по Dockerfile)

1.  **Запуск контейнера в интерактивном режиме или без демонизации**
    *   **Проблема:** Запуск контейнера командой `docker run -it my_app` привязывает его к текущей сессии терминала, и если закрыть терминал или нажать `Ctrl+C`, то контейнер умрет.
    *   **Решение:** Нужно использовать флаг `-d` (detach) для запуска контейнеров в качестве демонов: `docker run -d -p 5000:5000 my_app`. ТОгда контейнер продолжить работать фоном, даже если закрыт терминал.
2.  **Использование флага `--privileged` без необходимости**
    *   **Проблема:** Запуск контейнера с `--privileged` дает ему практически полный доступ к компьютеру. А это значит, что на практике контейнер может удалять или читать любые файлы, устанавливать вирусы на компьютер отслеживать все, что делает пользователь, то есть появляется огромная угроза безопасности и конфиденциальности.
    *   **Решение:** Избегайте `--privileged`. Если контейнеру нужны специфические права, используйте более точные флаги, такие как `--cap-add` или `--device`, чтобы предоставить только необходимые минимальные привилегии.
